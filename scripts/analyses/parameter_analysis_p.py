import numpy as np
from matplotlib import pyplot as plt
import matplotlib as mpl
import pandas as pd
import sys
sys.path.append('../helpers/')
from shifted_cmap import shiftedColorMap


folder = "20191026_1147"

data   = pd.read_csv("../../results/model/"+folder+"/parscan.csv")
# print(data)

#
# for i in np.arange(3,(len(p_e)/3)):
#     ii = int(i*3)
#     jj = int((i+1)*3)
#
#     t_diff = t_e[ii:jj] - t_e[0:3]
#     rho =
#     print(t_diff)
#

p_e = data.p_e.unique()
rho = data.rho.unique()
phi = data.phi.unique()



data['te_0'] = data.te.tolist()[0:int(len(data)/len(p_e))]*len(p_e)
data['te_diff'] = np.array(data.te)-np.array(data.te_0)
# print(data)
# np.diff(data.te_diff < 0)

epmin = np.min([data.te_diff])
epmax = np.max([data.te_diff])
orig_cmap = mpl.cm.RdBu
midpoint = np.absolute(epmin) / (epmax - epmin)
shifted_cmap = shiftedColorMap(orig_cmap, midpoint=midpoint, name='shiftedcmap')

# fig, axes = plt.subplots(nrows = int(np.ceil(len(p_e)**(1/2))),
#                          ncols = int(np.ceil(len(p_e)**(1/2))))

display_rho = 0.1
border_diff = list()
for i in np.arange(0,len(p_e)):
    ii = int(i*len(phi)*len(rho))
    jj = int((i+1)*len(phi)*len(rho))

    df = data[ii:jj]
    # m1 = np.append(np.diff(np.array(df.te_diff) < 0),False).tolist()
    # m2 = np.append(False, np.diff(np.array(df.te_diff) < 0)).tolist()
    # print(m1)
    # m  = [np.min([x,y]) for x, y in zip(m1,m2)]
    # print(m)
    mask = np.append(np.diff(np.array(df.te_diff) < 0),False)
    # maskb =
    df = df.assign(border = mask)
    border = df[ (df.border == True) & (df.rho == display_rho)]
    # print(border)
    if np.sum(df.border > 0):
        border_diff.append(np.array(border.te_diff)[0]-np.array(border.te_diff)[1])
    # print(np.array(border.te_diff)[0])

print(border_diff  )
    # print(slice)
    # grid = np.array(slice.te_diff).reshape((len(rho), len(phi)))
    # grid = np.flipud(grid.T)
    # print( grid)
    # im2 = axes[i,i+1].imshow(grid, extent= (data.rho.min(), data.rho.max(),
    #     data.phi.min(), data.phi.max()),
    #     interpolation = "nearest", cmap = shifted_cmap, aspect = "auto",
    #     vmin = epmin, vmax = epmax)

plt.plot(p_e[2:-1],border_diff[2:])
plt.xlabel("p_e")
plt.ylabel("surplus energy generated by original tainter model")
plt.show()


#
# fig.subplots_adjust(right=0.75)
# cbar_ax_ep = fig.add_axes([0.81, 0.525, 0.05, .355])
# # cbar_ax_st = fig.add_axes([0.81, 0.11 , 0.05, .355])
# fig.colorbar(im2, cax = cbar_ax_ep)
# # fig.colorbar(im, cax = cbar_ax_st)
#
# fig.text(0.05, 0.5, 'Efficiency ($\\phi$)', ha='center',
#     va='center', rotation='vertical')
# fig.text(0.5, 0.04, 'Link Density ($\\rho$)', ha='center', va='center')
# # fig.text(0.78, 0.7, 'Survival time', ha = 'center', va = "center", rotation = "vertical")
# fig.text(0.78, 0.3, 'Energy production', ha = 'center', va = "center", rotation = "vertical")
# # ax1.annotate("A", xy=(0.03, 0.9), xycoords="axes fraction", color = "white")
# # ax2.annotate("B", xy=(0.03, 0.9), xycoords="axes fraction", color = "white")
# # ax3.annotate("C", xy=(0.03, 0.9), xycoords="axes fraction", color = "black")
#
# plt.show()
